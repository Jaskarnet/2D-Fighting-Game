\chapter{Implementacja}
W niniejszym rozdziale przedstawiono szczegółową analizę implementacji dwuwymiarowej gry zręcznościowej z gatunku bijatyk. Omówienie obejmuje kluczowe aspekty techniczne projektu, takie jak tworzenie animacji, struktura klas, wzorce projektowe oraz implementacja mechanik gry, zarówno w trybie offline, jak i online. Szczególny nacisk położono na takie elementy, jak zarządzanie postaciami, detekcja kolizji, obsługa sieci oraz interfejs użytkownika, które razem stanowią rdzeń funkcjonalności i grywalności projektu.
\section{Tworzenie animacji}
\begin{figure}
	\centering
		\includegraphics[width=0.64\linewidth]{rys03/animacja}
	\caption{Proces tworzenia animacji}
	\label{fig:animacja}
\end{figure}
Na rysunku \ref{fig:animacja} pokazano proces tworzenia animacji. a) Na początku postać została zamodelowana w 3D. Użyto do tego narzędzia Blender. b) Następnie przeprowadzono \emph{rigging}, czyli proces dodawania szkieletu do modelu 3D, który pozwala na animowanie poszczególnych części ciała. c) Po ustawieniu postaci w pożądanych pozach, każda klatka animacji była renderowana i zapisywana jako seria oddzielnych plików graficznych (\emph{sprite'ów}). Te obrazy stanowiły podstawę dla każdego ruchu postaci w grze. d) Następnie używając narzędzia ImageMagick \emph{sprite'y} zostały połączone w jeden większy obraz zwany \emph{spritesheet'em}. e) Używając stworzonego przez autora pracy, na potrzeby tego projektu, narzędzia do edycji animacji \emph{Move Editor}, stworzono wpisy do każdej klatki, opisujące między innymi ruch postaci. f) W Move Editorze określano również \emph{hurtbox'y} i \emph{hitbox'y} dla każdej klatki animacji. \emph{Hurtbox} to obszar, w którym postać może otrzymać obrażenia, natomiast \emph{hitbox} to obszar, w którym postać zadaje obrażenia. Ta funkcjonalność jest kluczowa dla mechaniki gry, ponieważ decyduje o tym, kiedy ataki postaci trafiają lub są blokowane. Po zakończeniu edycji \emph{spritesheet} wraz z opisem klatek w formacie json zostały zapisane w odpowiedniej strukturze plików, aby mogły być bezpośrednio wykorzystane w grze.
% TO DO: a czy nie dałoby się stworzyć rysunku z białym tłem? Czarne tło źle wygląda na wydrukach.
\section{Struktura klas}
\begin{figure}
	\centering
		\includegraphics[width=1\linewidth]{rys03/struktura_klas}
	\caption{Struktura klas}
	\label{fig:struktura_klas}
\end{figure}

Na rysunku \ref{fig:struktura_klas} przedstawione są główne klasy stworzone na potrzeby gry. W poniższych podsekcjach przedstawiony jest krótki opis każdej z nich.
\subsection{Główna struktura gry}
\texttt{FightingGame} służy jako centrum zarządzania głównymi aspektami gry, takimi jak inicjalizacja, cykl życia gry oraz przełączanie pomiędzy różnymi ekranami (np. menu, gra itp.). W procesie inicjalizacji wykorzystuje klasę \texttt{GameAssetManager}, która odpowiada za wczytywanie i zarządzanie zasobami gry, takimi jak tekstury, dźwięki i inne elementy multimedialne. \texttt{MainMenuScreen}, \texttt{LoadingScreen}, \texttt{OfflineGameScreen}, \texttt{JoinOnlineGameScreen}, \texttt{HostOnlineGameScreen} oraz \texttt{OnlineGameScreen} są klasami reprezentującymi różne ekrany w grze, każdy z nich implementuje interfejs \texttt{Screen} dostarczony przez framework \texttt{libGDX}. Zapewniają one różnorodne interfejsy uzytkownika i są odpowiedzialne za prezentację odpowiedniego widoku w zależności od stanu gry.

\subsection{Mechaniki rozgrywki}
Klasa \texttt{Fighter} reprezentuje postać walczącą. Przechowuje ona wartości takie jak zdrowie, pozycję, \emph{hurtbox'y} i \emph{hitbox'y} postaci oraz stan w którym aktualnie się znajduje. Ten stan reprezentowany jest przez typ wyliczeniowy \texttt{State} i obejmuje takie sytuacje jak ,,chodzenie do przodu'', ,,cofanie się'', ,,kucanie'' jak i wykonywanie różnych ataków albo otrzymywanie ich na bloku lub bez niego. Na podstawie tej klasy często wykonuje się logika reszty programu. Dodatkowo klasa reprezentująca awatar, którym steruje gracz posiada zestaw ruchów zawarty w klasie \texttt{Movelist}. Ta klasa przetrzymuje poszczególne ruchy o klasie \texttt{Move}. Każdy cios jest opisany poprzez pojedyncze klatki za pomocą klasy \texttt{Frame}, w których znajduje się informacja o ruchu jaki postać ma wykonać, jaki zestaw obszarów okreslających kolizję ma mieć wpływ na postać w danym momencie oraz jaki \texttt{sprite} ma zostać wyświetlony.

\subsection{Wykrywanie kolizji, obsługa wejścia i wzorzec \emph{command} \cite{GPP}}
Klasy \texttt{Command}, \texttt{CommandFactory}, \texttt{DoNothingCommand}, \texttt{BlockStunCommand}, \texttt{HitStunCommand}, \texttt{SetHighStunCommand}, \texttt{MoveFighterCommand}, \texttt{StartGameCommand} wdrażają wzorzec programowania \emph{command} (polecenia), umozliwiając abstrakcyjne reprezentacje akcji, które mogą być wykonane w grze. \texttt{Command} jest interfejsem dla wszystkich komend, \texttt{CommandFactory} jest fabryką do tworzenia instancji komend, a pozostałe klasy są konkretnymi komendami, które mogą być wywołane przez graczy lub system gry. Klasa \texttt{InputHandler} zajmuje się obsługą wejścia od uzytkownika - tworzy komendy na podstawie przycisku naciśniętego przez gracza oraz aktualnego stanu postaci. \texttt{Collision} zarządza detekcją kolizji między postaciami w grze oraz wpływa na stan tych postaci. \texttt{Multiplayer} odpowiada za implementację funkcjonalności sieciowych, umożliwiając grę wieloosobową poprzez zarządzanie połaczeniami i komunikacją między graczami. Gdy postać jest sterowana przez gracza połączonego przez internet to właśnie ta klasa podaje komendy do wykonania przez jego awatar wpływając na działanie \texttt{InputHandler'a}.

\section{Fragmenty kodu}
W tej sekcji zostaną omówione fragmenty kodu, które zostały uznane przez autora pracy inżynierskiej za kluczowe w działaniu programu.
\subsection{Interfejs \texttt{Command}}
Na listingu \ref{list:command} zaprezentowano interfejs, który jest implementowany przez wiele innych klas. Interfejs ten nakazuje implementującym go klasom stworzenie metody \texttt{execute}, która najczęściej zmieniać ma stan jakiegoś obiektu (np.\ z klasy \texttt{Fighter}) oraz metody \texttt{undo}, mającej za zadanie wycofanie zmian wprowadzonych metodą \texttt{execute}. Dzięki temu podejściu można na przykład łatwo zmieniać przypisane do przycisków zadania lub stworzyć historię wciśniętych przycisków, a także system powtórek bazujących na logice \emph{undo}. Dodatkowo, tworzenie obiektów reprezentujących wykonywane akcje ułatwia proces tworzenia kodu sieciowego.
\begin{lstlisting}[language=Java,style=JavaStyle,label=list:command,caption=Interfejs \texttt{Command},
                   basicstyle=\footnotesize\ttfamily]
public interface Command {
    void execute(Entity entity);
    void undo(Entity entity);
}
\end{lstlisting}

\subsection{Klasa \texttt{Fighter}}
Klasa \texttt{Fighter} zarządza stanem i zachowaniem postaci w grze. Zawiera informacje o zdrowiu, listy obszarów trafień (\emph{hitboxes}) i obszarów, które mogą zostać trafione (\emph{hurtboxes}), oraz zestaw ruchów (\emph{movelist}). Wykorzystuje ona wzorzec programowania \emph{update}. Sprowadza się on do implementacji metody aktualizacji stanu, która symuluje jedną klatkę zachowania obiektu. Na listingu \ref{list:fighter} można zauważyć, że metoda ta tworzy rozkaz za pomocą klasy \texttt{InputHandler}, a~następnie wykonuje go. W kolejnym kroku, jeżeli gracz uczestniczy w rozgrywce online, jego komenda jest przesyłana do drugiego gracza z pomocą klasy \texttt{Multiplayer}. Na końcu postać w grze aktualizuje wyświetlany \texttt{sprite} oraz inne informacje dotyczące aktualnej klatki animacji.

\begin{lstlisting}[language=Java,style=JavaStyle,label=list:fighter,caption=Funkcja update w klasie Fighter,
                   basicstyle=\footnotesize\ttfamily]
public void update() {
    Command command = inputHandler.handleInput();
    command.execute(this);
    if (multiplayer != null && (player == Player.PLAYER1 || player == Player.PLAYER2)) {
        multiplayer.sendCommand(command);
    }
    updateAnimation();
}
\end{lstlisting}

\subsection{Klasa \texttt{OfflineGameScreen}}
Listing \ref{list:offline_game} przedstawia implementację klasy \texttt{OfflineGameScreen}. Klasa ta wykorzystuje wzorzec pętli gry (\emph{game loop pattern}), wraz z wzorcem aktualizacji (\emph{update pattern}), aby zarządzać cyklem życia gry w trybie \emph{offline}. Konstruktor inicjalizuje stan gry, przydzielając graczy i tworząc kolekcję bytów (\texttt{entities}), które będą aktualizowane i renderowane w każdym cyklu gry. Inicjalizuje również system kolizji, który jest odpowiedzialny za wykrywanie i rozwiązywanie interakcji między bytami. Klasa implementuje interfejs \texttt{Screen} z frameworka \texttt{LibGDX}, co oznacza, że musi dostarczyć implementację metody \texttt{render}, która jest wywoływana na każdą klatkę gry. Ta metoda jest rdzeniem pętli gry. Przyjmuje parametr \texttt{delta}, który reprezentuje czas, jaki upłynął od ostatniej klatki, umożliwiając aktualizacje oparte na czasie rzeczywistym. Na początku każdej klatki ekran jest czyszczony. 

Metoda \texttt{updateEntities} jest wywoływana w celu zaktualizowania stanu wszystkich bytów w grze. Zawiera logikę warunkową, która decyduje, czy byty powinny być aktualizowane w stanie bezczynności (\texttt{idle}), po zakończeniu rundy (\texttt{updateRoundEnd}), czy w standardowym trybie gry, gdzie każdy byt jest aktualizowany poprzez wywołanie jego metody update. Te dwie pierwsze są oddzielone od standardowego trybu ze względu na to że w trybie online będą one mogły wykonywać się po stronie klienta, niezależnie od przychodzących przez internet informacji od drugiego gracza. Po zaktualizowaniu bytów, system kolizji jest aktualizowany, aby sprawdzić i przetworzyć wszelkie kolizje, które miały miejsce pomiędzy bytami. 

Na koniec metoda \texttt{renderGame} odpowiada za narysowanie aktualnego stanu gry na ekranie.

\begin{lstlisting}[language=Java,style=JavaStyle,label=list:offline_game,caption=Klasa \texttt{OfflineGameScreen},
                   basicstyle=\footnotesize\ttfamily]
public class OfflineGameScreen implements Screen {
    FightingGame game;
    private Collection<Entity> entities;
    private Collision collision;
    ...// Pozostałe tekstury, dźwięki itp

    public OfflineGameScreen(FightingGame game) {
        // Przydzielanie graczy
        game.player1.setPlayer(Player.PLAYER1);
        game.player2.setPlayer(Player.PLAYER2);

        // Inicjalizacja kolekcji bytów i kolizji
        entities = new ArrayList<>();
        entities.add(game.player1);
        entities.add(game.player2);
        collision = new Collision(game.player1, game.player2); 
        ...// Pobieranie załadowanych zasobów za pomocą AssetManagera
    }

    @Override
    public void render(float delta) {
        ...
        //clear
        clearScreen();
        //update
        updateEntities();
        //render
        renderGame();
		...
    }
		
		private void updateEntities() {
        if (isCountdownActive || isFightMessageActive) {
            game.player1.updateIdle();
            game.player2.updateIdle();
        } else if (isWinnerMessageActive) {
            game.player1.updateRoundEnd();
            game.player2.updateRoundEnd();
        } else {
            for (Entity entity : entities) {
                entity.update();
            }
            collision.update();
        }
    }
		...
}
\end{lstlisting}